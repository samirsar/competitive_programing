uch like macros. The advantage is that execution time 
    is shortened because linker overhead is minimized. They are declared 
    by using the inline keyword when the function is declared: 
  
       inline void func(void) { cout << "printing inline function \n"; } 
  
    or by including the function declaration and code body within a class: 
  
       class test 
       { 
       public: 
       void func(void) { cout << "inline function within a class.\n"} 
       }; 
  
 Q. If I don't specify either public or private sections in a class, 
    what is the default? 
 A. In a class, all members are private by default if neither public nor 
    private sections are declared. 
  
 Q. What does the _seg modifier do? 
 A. Using _seg causes a pointer to become a storage place for a 
    segment value, rather than an offset ( or a segment/offset ). 
    For instance, if "int _seg *x" contains the value 0x40, 
    then when you use "*x", the value pointed to will be at 
    segment 0x40, offset 0. If you add a value to the pointer, 
    the value is multiplied by the size of the pointer type. That 
    new value is used as an offset, and is combined with the segment 
    value contained in the pointer. For instance, 
  
       int _seg *x; 
       int value; 
  
       x = (int _seg *)0x40; 
       value = *(x + 20); 
  
    value is assigned the value of the integer at 0x40:0x28 
    (Remember, 20 * sizeof(int) = 40 = 0x28). 
  
  
 Q. Can I statically allocate more than 64K of data in a single module? 
 A. Yes. Far data items are now supported: 
  
       ... 
       char far array1[60000L]; 
       char far array2[60000L]; 
       ... 
  
    For arrays larger than 64k use: 
  
       char huge array3[100000L]; 
  
 Q. What is a friend member function? 
 A. Declaring a friend gives non-members of a class access to the 
    non-public members of a class. 
  
 Q. Why do I get a "Type name expected" error on my definition of a 
    friend class in my new class? 
 A  You need to let the compiler know that the label you use for your 
    friend class is another class. If you do not want to define your 
    entire class, you can simply have "class xxx", where xxx is your 
    label. 
  
 Q: How can I output hex values in upper case using the iostream libraries? 
 A: You need to set the state of the stream using setf(). For example, 
  
       #include <iostream.h> 
  
       int main(void) 
       { 
          cout << hex; 
          cout << "\nNot upper-case : " << 255; 
          cout.setf(ios::upper-case); 
          cout << "\nUppercase     : " << 255; 
          return 0; 
        } 
  
 Q. What is the "this" pointer? 
 A. "this" is a local variable in the body of a non-static member function. 
    It is a pointer to the object for which the function was invoked. It 
    cannot be used outside of a class member function body. 
  
 Q. Why does a binary member function only accept a single argument? 
 A. The first argument is defined implicitly. 
  
 Q. Looking through the class libraries there are definitions in classes 
    which look like: 
       class test { 
           int funct( void ) const; 
       }; 
    What is the const keyword doing here? 
 A. There is a pointer to the object for which a function is called 
    known as the 'this' pointer.  By default the type of 'this' 
    is  X *const ( a constant pointer).  The const keyword changes the 
    type to const X *const ( a constant pointer to constant data ). 
  
 Q: I want to use _new_handler and set_new_handler. 
 A: Turbo C++ supports _new_handler and set_new_handler. The type of 
    _new_handler is as follows. 
        typedef void (*vfp)(void); 
        vfp _new_handler; 
        vfp set_new_handler( vfp ); 
  
 Q: I would like to use C++ fstreams on a file opened in binary mode, 
    how is this done? 
 A: Use ios::binary as the open mode for the file: 
        #include <fstream.h> 
        ifstream binfile; 
        binfile.open("myfile.bin", ios::binary); 
  
 Q: How can I get at the DOS file handle associated with my iostream? 
 A: Using a combination of member functions fd() and rdbuf() you can 
    get at the file handle. 
        #include <fstream.h> 
        #define fstrno(s)  (((s).rdbuf())->fd()) 
        ifstream test("test.txt"); 
        cout << "handle is " << fstrno(test) << '\n'; 
  
  
  
 I n t e g r a t e d    E n v i r o n m e n t 
 ---------------------------------------------------------------------- 
 Q: Why doesn't my mouse work well with Turbo C++? 
 A: The most likely cause is that you are using an older mouse driver. You'll 
    need to get a newer version.  Driver versions required for full 
    compatibility include: 
        Logitech driver 5.01+, Microsoft 7.04+, Genius 9.06+. 
  
  
 Q. Why is Turbo C++ not able to find any of my #include files? 
 A. The compiler searches for include files in the Turbo C++ Include 
    Directories path. You can specify this path through the 
    Options|Directories menu. The INSTALL program initially sets this 
    path to the directory where it copied all the Turbo C++ *.h files. 
  
 Q. Why do I get the message: 
       Linker Error: Unable to open input file 'C0x.OBJ' 
 A. The linker searches for Turbo C++ start-up and library files in the 
    Turbo C++ Library Directories path. You can specify this path through 
    the Options|Directories menu. The INSTALL program initially sets this 
    path to the directory where it copied the start-up and library files. 
    Also be sure that you installed the memory model that the linker 
    is looking for. The 'x' in the error message corresponds to the memory 
    model, e.g. 's' for small, 'l' for large, etc. 
  
 Q. How do I get Turbo C++ to link in my own libraries or use multiple 
    source files? 
 A. Turbo C++'s Project facility is designed to allow you to work with 
    multiple files. 
  
 Q. Why does the linker tell me that all the graphics library routines 
    are undefined? 
 A. The Options|Linker|Libraries|Graphics Library item must be set ON 
    if you are using any Turbo C++ graphics functions and have not 
    specified GRAPHICS.LIB in a project file. 
  
 Q. Why does Turbo C++ report "Unable to open include file 'stdarg.h'" 
    when I try to #include <stdio.h>? 
 A. The most probable reason is that you have exceeded the number 
    of files that DOS can have open simultaneously. Add the line 
  
       FILES=20 
  
    to your DOS CONFIG.SYS file. This allows DOS to open up to 20 
    files at the same time. CONFIG.SYS will only be effective after 
    you have rebooted your computer. See the IBM DOS Reference 
    Manual for details on the CONFIG.SYS file. 
  
 Q. Where is the TCINST.EXE utility I have used in previous versions 
    of the compiler? 
 A. The capabilities of TCINST have been incorporated into other areas 
    of the product and thus TCINST is no longer necessary.  To remap 
    key bindings, use the Turbo Editor Macro Compiler (TEMC).  Colors 
    can be changed from within the IDE under Options | Environment | Colors. 
  
 Q. When I Make, Run, or Trace a program, Turbo C++ sometimes goes 
    through the compile and link process even when the object files 
    are up-to-date. 
 A. Turbo C++'s MAKE logic works solely on a file's date and time 
    stamp. If one of your source files is marked with a date 
    that's sometime in the future, the object files that are 
    created from it will always be older than the source file, 
    and Turbo C++ will always try to rebuild the file. You can fix 
    this by using TOUCH.COM to set the file to the current date 
    and time. You should also make sure that your system's date 
    and time are always properly set. TOUCH.COM is documented in 
    the file UTIL.DOC. 
  
 Q. How come my old Turbo C project files don't work anymore? 
 A. Project files now contain much more information about a project now, 
    and hence are no longer stored in ASCII format. To create a project 
    file, select PROJECT from the main menu, and follow the menus. To 
    convert your old project files to the new format, use the supplied 
    utility file PRJCNVT.EXE (documented in UTIL.DOC). 
  
 Q. How can I convert my Turbo C 2.0 project files to the new 
    format? 
 A. There is a conversion utility in your Turbo C++ BIN directory 
    called PRJCNVT.EXE. This program will perform the conversion. 
  
 Q. How come my project file is automatically loaded when I start Turbo C++? 
    I want to work on a different program. 
 A. If there is only one project file in the current directory, Turbo C++ 
    will load and use that one file. If there are no project files, or 
    if there are multiple project files, Turbo C++ does not automatically 
    load one. Go ahead and create a new project. To use a specific project 
    file you can specify the name of that project file on the command 
    line used to start Turbo C++. For example, 'tc farley.prj' would 
    start up TC++ and load the 'farley' project. 
  
 Q. My right mouse button appears to do nothing. Can I change this so it 
    will set breakpoints? 
 A. Yes, under the menu for Options|Environment|Mouse there is a 
    dialog box for the right mouse button. You can change it to set 
    breakpoints, or to do many other things. 
  
 Q. How can I find out where my "null pointer assignment" is occurring? 
 A. Set a watch on the following expressions: 
  
            *(char *)0,4m 
            (char *)4 
  
    Step through the program. When the values change, the just-executed line 
    is the one that is causing the problem. 
  
 Q. When I compile my program, I get the following error: 
  
       Error: C:\TC\INCLUDE\STDIO.H: Overlays only supported in 
       medium, large, and huge memory models 
  
    What is happening? 
 A. The Overlay Support option has been selected and does not work 
    in the tiny, small, or compact memory models. You can turn this option 
    off with: 
      Options | Compiler | Code Generation | Overlay Support 
  
    
 Q. When I try to load a new file after editing a file, the first 
    file remains on the screen. How do I close the first file? 
 A. Use Alt-F3 to close the current file. Also, use F6 to move 
    from one file to the next, if there is more than one file 
    open at a time. 
  
 Q. I'm doing a search and replace operation, and the editor prompts me for 
    each replacement. I've selected "Change All", but it still does it. 
 A. To disable the prompting, you must unselect the "Prompt on replace" 
    option on the left side of the dialog box. 
  
 Q. When I try to use the any of the pseudo registers, like _AX, I 
    get the error message "Undefined symbol '_AX' in function..." 
    when I compile. Why? 
 A. You are only allowed to use the pseudo registers in the Turbo 
    C++ and ANSI modes of the compiler. You can change this setting 
    in the Options | Compiler | Source menu. 
  
 Q. Since I don't have a mouse, can I still copy blocks of code 
    from one file to another? 
 A. Yes. You can mark the beginning and end of a block by moving 
    to the appropriate area and pressing Ctrl-K-B (mark beginning) and 
    Ctrl-K-K (mark end). You can then use the copy and paste commands 
    in the Edit menu. 
  
 Q: How do I stop all of the files I have ever edited from constantly 
    being open when I bring up Turbo C++? 
 A: By default, Turbo C++ saves what is called the desktop configuration. 
    This configuration is saved in a file with a .DSK extension.  By deleting 
    any files of this type, then entering Options/Environment/Preferences 
    and removing the check from 'auto save desktop', you will begin with a 
    clean desktop each time you invoke Turbo C++. 
  
  
 C o m m a n d  -  L i n e    C o m p i l e r 
 ---------------------------------------------------------------------- 
 Q. Why is Turbo C++ not able to find any of my #include files? 
 A. The compiler searches for include files in the Turbo C++ Include 
    Directories path. You specify this path with the -I option. The INSTALL 
    program initially writes a configuration file (TURBOC.CFG) that 
    sets this path to the directory where it copied all the Turbo C++ 
    *.h files. 
  
 Q. Why do I get the message: 
       Linker Error: Unable to open input file 'C0x.OBJ' 
 A. The linker searches for Turbo C++ start-up and library files in the 
    Turbo C++ Library Directories path. You can specify this path with 
    the -L option. If you allow TCC to invoke the linker, it will search 
    the directories in the configuration file (TURBOC.CFG) written by the 
    INSTALL program. If you run TLINK, the configuration file is not read. 
    TLINK does use the configuration file TLINK.CFG, so you can specify 
    library paths in this file. 
  
 Q. Why does the linker tell me that all the graphics library routines are 
    undefined? 
 A. TCC will not search the graphics library unless you tell it to. 
    You should specify the graphics library on the command line. For 
    example, to compile BGIDEMO, type 
  
       TCC BGIDEMO.C GRAPHICS.LIB<Enter> 
  
 Q. I run TCC.EXE and get the error message: 
       Fatal: <filename>.def (<line #>): syntax error 
 A. Check your DATA statement on line number # in <filename>.def for the 
    correct code (that is, DATA PRELOAD). 
  
  
 G e n e r a l     I / O 
 ---------------------------------------------------------------------- 
 Q. The '\n' in cprintf() does not return the cursor to the 
    beginning of the line. It only moves the cursor down one line. 
 A. cprintf() interprets '\n' as a Line Feed. To force the cursor to 
    the beginning of the line, manually insert a Carriage Return: 
  
      cprintf("\n\r"); 
  
 Q. How do I print to the printer from a Turbo C++ program? 
 A. Turbo C++ uses a FILE pointer (stdprn) defined in the STDIO.H 
    file. You do not need to open stdprn before using it: 
  
       #include <stdio.h> 
       int main(void) 
       { 
           fprintf(stdprn, "Hello, printer!\n"); 
       } 
  
    Note that if your printer is line-buffered, the output is 
    flushed only after a '\n' is sent. 
  
 Q. I am reading and writing binary files. My program is translating 
    the Carriage Return (0x0D) and Line Feed (0x0A) characters. How do 
    I prevent this from happening? 
 A. Files opened in text mode will translate these characters for 
    DOS. To read a file in binary mode, open it in binary mode. 
    For example, 
  
      #include <stdio.h> 
      int main(void) 
      { 
         FILE *binary_fp; 
         char buffer[100]; 
  
         binary_fp = fopen("MYFILE.BIN", "rb"); 
  
         fread(buffer, sizeof(char), 100, binary_fp); 
  
                    : 
      } 
  
    The default file mode is text. 
  
 Q. Why don't printf() and puts() print text in color? 
 A. Use the console I/O functions cprintf() and cputs() for color output. 
  
      #include <conio.h> 
      int main(void) 
      { 
          textcolor(BLUE); 
          cprintf("I'm blue."); 
      } 
  
 Q. How do I print a long integer? 
 A. Use the "%ld" format: 
  
      long int l = 70000L; 
      printf("%ld", l); 
  
 Q. How do I print a long double? 
 A. Use the "%Lf" format. 
  
      long double ldbl = 1E500; 
      printf("%Lf", ldbl); 
  
  
 E x a m p l e   P r o g r a m s 
 ---------------------------------------------------------------------- 
 Q. How do I compile the BGIDEMO program? 
 A. 1. Make sure that the following Turbo C++ files are in your 
       current directory: 
  
         BGIDEMO.C 
         *.BGI 
         *.CHR 
  
    2. Run Turbo C++. 
  
    3. Load BGIDEMO.C into the Editor by pressing F3, then typing 
       BGIDEMO<Enter> 
  
    3. Go to the Run menu and choose the Run item. 
  
 Q. How do I create a COM file? 
 A. DOS versions 3.2 and earlier include an EXE2BIN utility that 
    converts EXE files to COM files. Users who do not have EXE2BIN can 
    use TLINK, the Turbo C++ command-line linker, to create a COM file 
    instead of an EXE file. Use the /t option. For example: 
  
       TCC -mt -lt tiny 
  
    will create TINY.COM instead of TINY.EXE. The -l switch passes 
    the /t argument to the linker in this case. 
  
    There are certain limitations in converting an EXE file to a COM 
    file. These limitations are documented in the IBM Disk Operating 
    System manual under EXE2BIN. 
  
    Turbo C++'s TINY model is compatible with the COM format, but programs 
    that use Turbo C++'s floating-point routines cannot be used in a 
    TINY model application. 
  
  
 G r a p h i c s 
 ---------------------------------------------------------------------- 
 Q. Why do I get the error message: 
  
       BGI Error: graphics not initialized (use 'initgraph') 
  
    when I use a graphics function? My program has already 
    called initgraph(). 
 A. For some reason initgraph() failed. To find out why, check 
    the return value of graphresult(). For example: 
  
      #include <graphics.h> 
      int main(void) 
      { 
        int gerr;   /* graphics error */ 
        int gdriver = DETECT, gmode; 
  
        /* Initialize graphics using auto-detection and look 
           for the .BGI and .CHR files in the C:\TC\BGI directory. 
        */ 
        initgraph(&gdriver, &gmode, "C:\\TC\\BGI"); 
  
        if ((gerr = graphresult()) != grOk) 
        { 
            printf("Error : %s\n", grapherrormsg(gerr)); 
            exit(1); 
        } 
               : 
      } 
  
  
 M a t h  /  F l o a t i n g    P o i n t 
 ---------------------------------------------------------------------- 
 Q. Why do I get incorrect results from all the math library 
    functions like cos(), tan() and atof()? 
 A. You must #include <math.h> before you call any of the standard 
    Turbo C++ math functions. In general, Turbo C++ assumes that a function 
    that is not declared returns an int. In the case of math functions, 
    they usually return a double. For example 
  
        /* WRONG */                       /* RIGHT */ 
                                          #include <math.h> 
        int main(void)                    int main(void) 
        {                                 { 
          printf("%f", cos(0));             printf("%f", cos(0)); 
        }                                 } 
  
 Q. How do I "trap" a floating-point error? 
 A. See the signal() and matherr() functions in the online help. The 
    signal() function may be used to trap errors in the 80x87 or the 
    80x87 emulator. The matherr() function traps errors in the Math 
    Library functions. 
  
  
 L i n k e r    E r r o r s 
 ---------------------------------------------------------------------- 
 Q. I am linking C functions with C++ functions.  The linker reports that 
    all of my C functions are undefined.  Why? 
 A. Linking C++ modules with C modules requires the use of a linkage 
    specification.  Prototypes for C functions within C++ modules must 
    be in one of the following forms: 
  
        extern "C" declaration 
        extern "C" { declarations } 
  
    For example, if a C module contains functions 
    "char *SCopy(char*, char*);" and "void ClearScreen(void)", they 
    must be declared in a C++ module in one of the following ways: 
  
        extern "C" char *SCopy(char*, char*); 
        extern "C" void ClearScreen(void); 
  
    or 
  
        extern "C" { 
            char *SCopy(char*, char*) 
            void ClearScreen(void); 
        } 
  
    For further examples, see the standard header files.  For additional 
    comment, see Common C++ Questions. 
  
 Q. Why do I get the message: 
      Linker Error: Unable to open input file 'C0x.OBJ' 
 A. See the "Integrated Environment" section above. 
  
 Q. Why do I get the message: 
      Linker Error: Undefined symbol '_main' in module C0 
 A. Every C program must contain a function called main(). This 
    is the first function executed in your program. The function 
    name must be all in lower case. If your program does not 
    have one, create one. If you are using multiple source files, 
    the file that contains the function main() must be one of 
    the files listed in the Project. 
  
    Note that an underscore character '_' is prepended to all 
    external Turbo C++ symbols. 
  
 Q. Why does the linker tell me that all the graphics library 
    routines are undefined? 
 A. See the "Integrated Environment" and "Command-line Compiler" 
    sections above. 
  
 Q. What is a 'Fixup overflow'? 
 A. See the listing of TLINK error messages in the Turbo C++ 
    User's Guide. 
  
 Q. I am linking my own assembly language functions with Turbo C++. 
    The linker reports that all of my functions are undefined. 
 A. Make sure that you have put an underbar character '_' in front of all 
    assembly language function names to be called by Turbo C++. Your 
    assembly language program should be assembled with Case Sensitivity. 
    If compiling as C++ (rather than C), see the "Common C++ Questions" 
    section above which discusses the use of extern "C". 
  
 Q: I am getting an error out of the linker "segment group exceeds 64K : 
    _text". 
 A: If you are using the BGIOBJ utility, the default segment into which 
    the objects will be place is _text.  You should try using BGIOBJ with 
    the /f option to place the resultant objects into a separate segment. 
    You will then need to use the functions registerfarbgidriver and 
    registerfarbgifont to register the objects for the graphics system. 
    See UTIL.DOC for instructions on using these functions. 
  
 Q: I am attempting to link Turbo C 2.0 objects into my Turbo C++ programs, 
    but continually get unresolved external symbols at link time. 
 A: The names of many of the "helper" functions have changed from what they 
    were in Turbo C 2.0. If you are getting undefined symbols like _LXLSH and 
    _FMUL, this is the problem you are running into.  Your best solution is to 
    get the source code to the old object modules and recompile with Turbo C++. 
    The only other possibility would be to extract the helper function objects 
    from the Turbo C 2.0 libraries and link them into the Turbo C++ program. 
  
 Q. I'm porting an application that uses communal variables to C++. 
    I've set up the compiler to recognize them, but I still get linker 
    errors: 
  
      Error: <name> defined in module <a> is duplicated in module <b> 
  
 A. C++ doesn't support explicit COMDEFs; you must use static 
    variables or switch to C. 
  
 O t h e r    Q u e s t i o n s 
 ---------------------------------------------------------------------- 
 Q. I get a "floating point formats not linked" message when I run 
    my program. What can I do about it? 
  
 A. Floating point formats (for scanf() and related functions) are 
    not always linked, for savings in executable size. To force their 
    inclusion, put the following somewhere in your source files: 
  
      extern unsigned _floatconvert; 
      #pragma extref _floatconvert 
  
 Q. How do I change the stack size? 
 A. The size of the stack of a Turbo C++ program is determined at 
    run time by the global variable _stklen. To change the size 
    to, for example, 10,000 bytes, include the following line in 
    your program: 
  
      extern unsigned _stklen = 10000; 
  
    This statement must not be inside any function definition. 
    The default stack size is 4,096 bytes (4K). 
  
 Q. I'm getting a 'Stack Overflow!' message when I run my program. 
    How can I work around this? 
 A. You may increase the stack size by following the procedure above. Stack 
    overflows are usually caused by a large amount of local data or 
    recursive functions. You can decrease the amount of stack space 
    used by declaring your local variables static: 
  
         int main(void)                int main(void) 
         {                             { 
             char x[5000];     -->          static char x[5000]; 
                 :                                : 
         }                             } 
  
    Of course, you should be aware that there are other effects 
    that the "static" keyword has, as applied here. 
  
 Q. My program comes up with the message 'Null pointer assignment' 
    after it terminates. What does this mean? 
 A. Before a small-data model Turbo C++ program returns to DOS, it will 
    check to see if the beginning of its data segment has been corrupted. 
    This message is to warn you that you have used uninitialized pointers 
    or that your program has corrupted memory in some other way. 
  
 Q. Why are .EXE files generated by TC.EXE larger than those generated by 
    TCC.EXE? 
 A. In the default configuration, TC.EXE includes debugging information in 
    the .EXE files that it creates, and TCC.EXE does not. If you don't want 
    to produce this debugging information, you can shut it off in the 
    Integrated Development Environment by selecting Alt-O|B|N. 
  
 Q. Why do I get "declaration syntax error" messages on dos.h? 
 A. You have set the "ANSI keywords only" option ON. Keep this option OFF 
    when using any keywords specific to Turbo C++. 
  
 Q. I have a working program that dynamically allocates memory 
    using malloc() or calloc() in small data models (tiny, small, 
    and medium). When I compile this program in large data models 
    (compact, large, and huge), my program hangs. 
 A. Make sure that you have #include <alloc.h> in your program. 
  
 Q. I am linking my own assembly language functions with Turbo C++. 
    But the linker reports that all of my functions are undefined. 
 A. See answer above in the "Linker" section. 
  
 Q. My far pointers "wrap around" when they are incremented over 64K. 
    How do I reference a data object that is greater than 64K? 
 A. Use huge pointers. 
  
 Q. How do I interface Turbo C++ routines to a Turbo Pascal program? 
 A. See the example programs CPASDEMO.PAS and CPASDEMO.C. 
  
 Q. How do I get Clipper to link with Turbo C++? 
 A. If you are having trouble, contact Nantucket Technical Support. 
  
 Q. I'm trying to build an app based on one of Borland's libraries 
    (Turbo Vision, the container classes in the CLASSLIB directory, 
    or the Runtime Library),  and I get linker errors, or it won't 
    run right. What's going wrong? 
  
 A. You may be using a switch that affects linkage in your files, 
    that was not used when the library itself was compiled, or you 
    need to change the library in question. Here are some examples: 
  
    - If you use far vtables (-Vf or Options|Compiler|C++|Far 
      virtual tables) to compile a file you developed which 
      includes iostream.h, it won't build correctly until you 
      rebuild the iostream library with the same option. 
  
    - If you use word alignment (-a or Options|Compiler|Code 
      Generation|Word alignment) in building a Turbo Vision 
      application, you must build the Turbo Vision library from 
      source with the same option. 
 


                                                                                                                                                                                                                                                                                                                                                                                                                                                      .file   M   þÿ  gcrtexe.c              Q                                q              |   @                        £   P                        É   `                        ï   0                                                   .                           L             W  à                        m                           ™  0          ¦                      envp           argv           argc                ¾  




CONTENTS
___________________________________________________________________________





Chapter 1  BASM.DOC                1         Inline assembly and register
  Inline assembly language . . . . 1         variables . . . . . . . . .  7
    BASM . . . . . . . . . . . . . 1         Inline assembly, offsets, and
    Inline syntax  . . . . . . . . 2         size overrides  . . . . . .  7
    Opcodes  . . . . . . . . . . . 3       Using C structure members . .  7
      String instructions  . . . . 5       Using jump instructions and
      Prefixes . . . . . . . . . . 5       labels  . . . . . . . . . . .  8
      Jump instructions  . . . . . 5     Interrupt functions . . . . . .  9
      Assembly directives  . . . . 6     Using low-level practices . . . 10
    Inline assembly references to
    data and functions . . . . . . 6   Index                             13

































                                     i






TABLES
___________________________________________________________________________





1.1: Opcode mnemonics  . . . . . . 4   1.3: Jump instructions  . . . . . .6
1.2: String instructions . . . . . 5










































                                    ii












Online document
___________________________________________________________________________



                                                                   BASM.DOC


                    This online file tells you how to use the Turbo C++
                    built-in inline assembler (BASM) to include assembly
                    language routines in your C and C++ programs without
                    any need for a separate assembler. Such assembly
                    language routines are called inline assembly, because
                    they are compiled right along with your C routines,
                    rather than being assembled separately, then linked
                    together with modules produced by the C compiler.

                    Of course, Turbo C++ also supports traditional mixed-
                    language programming in which your C program calls
                    assembly language routines (or vice-versa) that are
                    separately assembled by TASM (Turbo Assembler), sold
                    separately. In order to interface C and assembly
                    language, you must know how to write 80x86 assembly
                    language routines and how to define segments, data
                    constants, and so on. You also need to be familiar with
                    calling conventions (parameter passing sequences) in C
                    and assembly language, including the pascal parameter
                    passing sequence in C.

   Inline assembly  =======================================================
          language
                    Turbo C++ lets you write assembly language code right
                    inside your C and C++ programs. This is known as inline
                    assembly.

------------------  If you don't invoke TASM, Turbo C++ can assemble your
              BASM  inline assembly instructions using the built-in
------------------  assembler (BASM). This assembler can do everything TASM
                    can do with the following restrictions:

                    o It cannot use assembler macros




                                   - 1 -






                    o It cannot handle 80386 or 80486 instructions

                    o It does not permit Ideal mode syntax

                    o It allows only a limited set of assembler directives
                      (see page 6)


------------------  Of course, you also need to be familiar with the 80x86
     Inline syntax  instruction set and architecture. Even though you're
------------------  not writing complete assembly language routines, you
                    still need to know how the instructions you're using
                    work, how to use them, and how not to use them.

                    Having done all that, you need only use the keyword asm
                    to introduce an inline assembly language instruction.
                    The format is

                       asm  opcode  operands ; or newline

                    where

                    o opcode is a valid 80x86 instruction (Table 1.0 lists
                      all allowable opcodes).

                    o operands contains the operand(s) acceptable to the
                      opcode, and can reference C constants, variables, and
                      labels.

                    o ; or newline is a semicolon or a new line, either of
                      which signals the end of the asm statement.

                    A new asm statement can be placed on the same line,
                    following a semicolon, but no asm statement can
                    continue to the next line.

                    To include a number of asm statements, surround them
                    with braces:

 The initial brace   asm {
must appear on the      pop ax; pop ds
  same line as the      iret
      asm keyword.   }

                    Semicolons are not used to start comments (as they are
                    in TASM). When commenting asm statements, use C-style
                    comments, like this:




                                   - 2 -






                     asm mov ax,ds;               /* This comment is OK */
                     asm {pop ax; pop ds; iret;}  /* This is legal too */
                     asm push ds                  ;THIS COMMENT IS
                     INVALID!!

                    The assembly language portion of the statement is
                    copied straight to the output, embedded in the assembly
                    language that Turbo C++ is generating from your C or
                    C++ instructions. Any C symbols are replaced with ap-
                    propriate assembly language equivalents.

                    Because the inline assembly facility is not a complete
                    assembler, it may not accept some assembly language
                    constructs. If this happens, Turbo C++ will issue an
                    error message. You then have two choices. You can
                    simplify your inline assembly language code so that the
                    assembler will accept it, or you can use an external
                    assembler such as TASM. However, TASM might not identi-
                    fy the location of errors, since the original C source
                    line number is lost.

                    Each asm statement counts as a C statement. For
                    example,

                     myfunc()
                     {
                        int  i;
                        int x;

                        if  (i > 0)
                           asm  mov  x,4
                        else
                           i = 7;
                     }

                    This construct is a valid C if statement. Note that no
                    semicolon was needed after the mov x,4 instruction. asm
                    statements are the only statements in C that depend on
                    the occurrence of a new line. This is not in keeping
                    with the rest of the C language, but this is the
                    convention adopted by several UNIX-based compilers.

                    An assembly statement can be used as an executable
                    statement inside a function, or as an external
                    declaration outside of a function. Assembly statements
                    located outside any function are placed in the data
                    segment, and assembly statements located inside func-
                    tions are placed in the code segment.



                                   - 3 -






------------------  You can include any of the 80x86 instruction opcodes as
           Opcodes  inline assembly statements. There are four classes of
------------------  instructions allowed by the Turbo C++ compiler:

                    o normal instructions--the regular 80x86 opcode set

                    o string instructions--special string-handling codes

                    o jump instructions--various jump opcodes

                    o assembly directives--data allocation and definition

                    Note that all operands are allowed by the compiler,
                    even if they are erroneous or disallowed by the
                    assembler. The exact format of the operands is not
                    enforced by the compiler.


                    -------------------------------------------------------

Opcode mnemonics    aaa            fclex          fldenv         fstenv
                    aad            fcom           fldl2e         fstp
                    aam            fcomp          fldl2t         fstsw
                    aas            fcompp         fldlg2         fsub
                    adc            fdecstp**      fldln2         fsubp
  This table lists  add            fdisi          fldpi          fsubr
        the opcode  and            fdiv           fldz           fsubrp
mnemonics that can  bound          fdivp          fmul           ftst
 be used in inline  call           fdivr          fmulp          fwait
        assembler.  cbw            fdivrp         fnclex         fxam
                    clc            feni           fndisi         fxch
                    cld            ffree**        fneni          fxtract
Inline assembly in  cli            fiadd          fninit         fyl2x
 routines that use  cmc            ficom          fnop           fyl2xp1
    floating-point  cmp            ficomp         fnsave         hlt
 emulation doesn't  cwd            fidiv          fnstcw         idiv
       support the  daa            fidivr         fnstenv        imul
    opcodes marked  das            fild           fnstsw         in
          with **.  dec            fimul          fpatan         inc
                    div            fincstp**      fprem          int
                    enter          finit          fptan          into
                    f2xm1          fist           frndint        iret
                    fabs           fistp          frstor         lahf
                    fadd           fisub          fsave          lds
                    faddp          fisubr         fscale         lea
                    fbld           fld            fsqrt          leave
                    fbstp          fld1           fst            les
                    fchs           fldcw          fstcw          lsl



                                   - 4 -






                    mul            or             ret            stc
                    neg            out            rol            std
                    nop            pop            ror            sti
                    not            popa           sahf           sub
                                   popf           sal            test
                                   push           sar            verr
                                   pusha          sbb            verw
                                   pushf          shl            wait
                                   rcl            shr            xchg
                                   rcr            smsw           xlat
                                                                 xor
                    -------------------------------------------------------


                    String instructions
                    =======================================================

                    In addition to the listed opcodes, the string
                    instructions given in the following table can be used
                    alone or with repeat prefixes.
          String
    instructions    -------------------------------------------------------
                       cmps          insw           movsb          outsw          stos
                       cmpsb         lods           movsw          scas           stosb
                       cmpsw         lodsb          outs           scasb          stosw
                       ins           lodsw          outsb          scasw
                       insb          movs

                    -------------------------------------------------------


                    Prefixes
                    =======================================================

                    The following prefixes can be used:

                     lock   rep   repe   repne   repnz   repz


                    Jump instructions
                    =======================================================

                    Jump instructions are treated specially. Since a label
                    cannot be included on the instruction itself, jumps
                    must go to C labels (discussed in "Using jump
                    instructions and labels" on page 8). The allowed jump
                    instructions are given in the next table.



                                   - 5 -






                    Table 1.3: Jump instructions (continued)_______________

            Jump    -------------------------------------------------------
    instructions      ja      jge     jnc      jns     loop
                      jae     jl      jne      jnz     loope
                      jb      jle     jng      jo      loopne
                      jbe     jmp     jnge     jp      loopnz
                      jc      jna     jnl      jpe     loopz
                      jcxz    jnae    jnle     jpo
                      je      jnb     jno      js
                      jg      jnbe    jnp      jz

                    -----------------------------------------


                    Assembly directives
                    =======================================================

                    The following assembly directives are allowed in Turbo
                    C++ inline assembly statements:

                      db      dd      dw       extrn


------------------  You can use C symbols in your asm statements; Turbo C++
   Inline assembly  automatically converts them to appropriate assembly
references to data  language operands and appends underscores onto
     and functions  identifier names. You can use any symbol, including
------------------  automatic (local) variables, register variables, and
                    function parameters.

                    In general, you can use a C symbol in any position
                    where an address operand would be legal. Of course, you
                    can use a register variable wherever a register would
                    be a legal operand.

                    If the assembler encounters an identifier while parsing
                    the operands of an inline assembly instruction, it
                    searches for the identifier in the C symbol table. The
                    names of the 80x86 registers are excluded from this
                    search. Either uppercase or lowercase forms of the
                    register names can be used.









                                   - 6 -






                    Inline assembly and register variables
                    =======================================================

                    Inline assembly code can freely use SI or DI as scratch
                    registers. If you use SI or DI in inline assembly code,
                    the compiler won't use these registers for register
                    variables.


                    Inline assembly, offsets, and size overrides
                    =======================================================

                    When programming, you don't need to be concerned with
                    the exact offsets of local variables. Simply using the
                    name will include the correct offsets.

                    However, it may be necessary to include appropriate
                    WORD PTR, BYTE PTR, or other size overrides on assembly
                    instruction. A DWORD PTR override is needed on LES or
                    indirect far call instructions.


------------------  You can reference structure members in an inline
 Using C structure  assembly statement in the usual fashion (that is,
           members  variable.member). In such a case, you are dealing with
------------------  a variable, and you can store or retrieve values.
                    However, you can also directly reference the member
                    name (without the variable name) as a form of numeric
                    constant. In this situation, the constant equals the
                    offset (in bytes) from the start of the structure
                    containing that member. Consider the following program
                    fragment:

                     struct myStruct {
                        int a_a;
                        int a_b;
                        int a_c;
                     } myA ;

                     myfunc()
                     {
                        ...
                        asm  {mov  ax, myA.a_b
                              mov  bx, [di].a_c
                             }
                        ...
                     }




                                   - 7 -






                    We've declared a structure type named myStruct with
                    three members, a_a, a_b, and a_c; we've also declared a
                    variable myA of type myStruct. The first inline
                    assembly statement moves the value contained in myA.a_b
                    into the register AX. The second moves the value at the
                    address [di] + offset(a_c) into the register BX (it
                    takes the address stored in DI and adds to it the
                    offset of a_c from the start of myStruct). In this
                    sequence, these assembler statements produce the
                    following code:

                     mov  ax, DGROUP : myA+2
                     mov  bx, [di+4]

                    Why would you even want to do this? If you load a
                    register (such as DI) with the address of a structure
                    of type myStruct, you can use the member names to
                    directly reference the members. The member name
                    actually can be used in any position where a numeric
                    constant is allowed in an assembly statement operand.

                    The structure member must be preceded by a dot (.) to
                    signal that a member name, rather than a normal C
                    symbol, is being used. Member names are replaced in the
                    assembly output by the numeric offset of the structure
                    member (the numeric offset of a_c is 4), but no type
                    information is retained. Thus members can be used as
                    compile-time constants in assembly statements.

                    However, there is one restriction. If two structures
                    that you are using in inline assembly have the same
                    member name, you must distinguish between them. Insert
                    the structure type (in parentheses) between the dot and
                    the member name, as if it were a cast. For example,

                       asm   mov    bx,[di].(struct tm)tm_hour


------------------  You can use any of the conditional and unconditional
        Using jump  jump instructions, plus the loop instructions, in
  instructions and  inline assembly. They are only valid inside a function.
            labels  Since no labels can be defined in the asm statements,
------------------  jump instructions must use C goto labels as the object
                    of the jump. If the label is too far away, the jump
                    will be automatically converted to a long-distance
                    jump. Direct far jumps cannot be generated.





                                   - 8 -






                    In the following code, the jump goes to the C goto
                    label a.

                     int     x()
                     {
                     a:                /* This is the goto label "a" */
                        ...
                        asm  jmp  a    /* Goes to label "a" */
                        ...
                     }

                    Indirect jumps are also allowed. To use an indirect
                    jump, you can use a register name as the operand of the
                    jump instruction.


   Interrupt func-  =======================================================
             tions
                    The 80x86 reserves the first 1024 bytes of memory for a
                    set of 256 far pointers--known as interrupt vectors--to
                    special system routines known as interrupt handlers.
                    These routines are called by executing the 80x86
                    instruction

                      int  int#

                    where int# goes from 0h to FFh. When this happens, the
                    computer saves the code segment (CS), instruction
                    pointer (IP), and status flags, disables the
                    interrupts, then does a far jump to the location
                    pointed to by the corresponding interrupt vector. For
                    example, one interrupt call you're likely to see is

                      int  21h

                    which calls most DOS routines. But many of the
                    interrupt vectors are unused, which means, of course,
                    that you can write your own interrupt handler and put a
                    far pointer to it into one of the unused interrupt
                    vectors.

                    To write an interrupt handler in Turbo C++, you must
                    define the function to be of type interrupt; more
                    specifically, it should look like this:

                     void  interrupt myhandler(bp, di, si, ds, es, dx,




                                   - 9 -






                                               cx, bx, ax, ip, cs, flags,
                     ... );

                    As you can see, all the registers are passed as
                    parameters, so you can use and modify them in your code
                    without using the pseudovariables discussed earlier in
                    this online file. You can also pass additional
                    parameters (flags, ...) to the handler; those should be
                    defined appropriately.

                    A function of type interrupt will automatically save
                    (in addition to SI, DI, and BP) the registers AX
                    through DX, ES, and DS. These same registers are
                    restored on exit from the interrupt handler.

                    Interrupt handlers may use floating-point arithmetic in
                    all memory models. Any interrupt handler code that uses
                    an 80x87 must save the state of the chip on entry and
                    restore it on exit from the handler.

                    An interrupt function can modify its parameters.
                    Changing the declared parameters will modify the
                    corresponding register when the interrupt handler
                    returns. This may be useful when you are using an
                    interrupt handler to act as a user service, much like
                    the DOS INT 21 services. Also, note that an interrupt
                    function exits with an IRET (return from interrupt)
                    instruction.

                    So, why would you want to write your own interrupt
                    handler? For one thing, that's how most memory-resident
                    routines work. They install themselves as interrupt
                    handlers. That way, whenever some special or periodic
                    action takes place (clock tick, keyboard press, and so
                    on), these routines can intercept the call to the
                    routine handling the interrupt and see what action
                    needs to take place. Having done that, they can then
                    pass control on to the routine that was there.


   Using low-level  =======================================================
         practices
                    You've already seen a few examples of how to use these
                    different low-level practices in your code; now it's
                    time to look at a few more. Let's start with an
                    interrupt handler that does something harmless but
                    tangible (or, in this case, audible): It beeps whenever
                    it's called.



                                  - 10 -






                    First, write the function itself. Here's what it might
                    look like:

                     #include        <dos.h>

                     void  interrupt  mybeep(unsigned bp, unsigned di,
                     unsigned si,
                                             unsigned ds, unsigned es,
                     unsigned dx,
                                             unsigned cx, unsigned bx,
                     unsigned ax)
                     {
                        int     i, j;
                        char    originalbits, bits;
                        unsigned char   bcount = ax >> 8;

                        /* Get the current control port setting */
                        bits = originalbits = inportb(0x61);

                        for (i = 0; i <= bcount; i++){

                           /* Turn off the speaker for awhile */
                           outportb(0x61, bits & 0xfc);
                           for (j = 0; j <= 100; j++)
                              ;   /* empty statement */

                           /* Now turn it on for some more time */
                           outportb(0x61, bits | 2);
                           for (j = 0; j <= 100; j++)
                              ;   /* another empty statement */
                           }

                        /* Restore the control port setting */
                        outportb(0x61, originalbits);
                     }

                    Next, write a function to install your interrupt
                    handler. Pass it the address of the function and its
                    interrupt number (0 to 255 or 0x00 to 0xFF).

                     void  install(void interrupt (*faddr)(), int inum)
                     {
                        setvect(inum, faddr);
                     }

                    Finally, call your beep routine to test it out. Here's
                    a function to do just that:




                                  - 11 -






                     void  testbeep(unsigned char bcount, int inum)
                     {
                        _AH = bcount;
                        geninterrupt(inum);
                     }

                    Your main function might look like this:

                     main()
                     {
                        char  ch;

                        install(mybeep,10);
                        testbeep(3,10);
                        ch = getch();
                     }

                    You might also want to preserve the original interrupt
                    vector and restore it when your main program is
                    finished. Use the getvect and setvect functions to do
                    this.






























                                  - 12 -






INDEX
___________________________________________________________________________





A                                       F
asm (keyword) 2                         floating point
  braces and 2                            arithmetic
assembler                                   interrupt functions and 10
  built in 1                            functions
assembly language                         calling
  inline 1                                  in inline assembly code 6
    braces and 2
    C structure members and 7
      restrictions 8                    G
    calling functions 6                 goto statements
    commenting 2                          assembly language and 8
    directives 6
    goto in 8
    jump instructions 5, 8              I
    option (*B) 1                       INT instruction 9
    referencing data in 6               interrupt (keyword) 9
    register variables in 7             interrupts
    semicolons and 3                      beep
    size overrides in 7                     example 11
    syntax 2                              functions
    variable offsets in 7                   example of 10
                                            floating-point arithmetic in 10
                                          handlers
B                                           calling 11
braces                                      installing 11
  asm keyword and 2                         programming 9
built-in assembler 1

                                        J
C                                       jump instructions, inline assembly language
command-line compiler                     table 5
  options                                 using 8
    assembly language and 1
    -B (inline assembler code) 1
    inline assembler code  1            L
comments                                labels
  inline assembly language code 2         in inline assembly code 8






Index                                                                    13






M                                       repeat prefix opcodes 5
memory-resident routines 10

                                        S
O                                       size overrides in inline assembly
opcodes 3                                 code 7
  defined 2                             software interrupt instruction 9
  mnemonics                             sounds
    table 4                               beep 11
  repeat prefixes 5                     structures
operands (assembly language) 2            members
                                            in inline assembly code 7
                                              restrictions 8
P                                      
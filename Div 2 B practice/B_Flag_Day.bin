

Online document
___________________________________________________________________________

                                              The container class libraries


                                  CONTENTS




1  The container class libraries   1     Member functions  . . . . . . . 38
What's new since version 1.0?  . . 1     Friends . . . . . . . . . . . . 40
Why two sets of libraries? . . . . 3   Array . . . . . . . . . . . . . . 41
Container basics . . . . . . . . . 4     Example . . . . . . . . . . . . 41
    Object-based and other               Member functions  . . . . . . . 42
    classes  . . . . . . . . . . . 6   ArrayIterator . . . . . . . . . . 43
  Class categories . . . . . . . . 6     Member functions  . . . . . . . 43
  Non-container classes  . . . . . 7   Association . . . . . . . . . . . 44
    Error class  . . . . . . . . . 7     Member functions  . . . . . . . 44
    Sortable class . . . . . . . . 7     Example . . . . . . . . . . . . 45
    Association class  . . . . . . 8   Bag . . . . . . . . . . . . . . . 47
  Container classes  . . . . . . . 8     Member functions  . . . . . . . 47
  Containers and ownership . . . . 9   BaseDate  . . . . . . . . . . . . 49
  Container iterators  . . . . .  11     Member functions  . . . . . . . 49
  Sequence classes . . . . . . .  12   BaseTime  . . . . . . . . . . . . 51
  Collections  . . . . . . . . .  12     Member functions  . . . . . . . 51
    Unordered collections  . . .  13   Btree . . . . . . . . . . . . . . 53
    Ordered collections  . . . .  13     Member functions  . . . . . . . 53
The BIDS template library  . . .  13     Friends . . . . . . . . . . . . 55
  Templates, classes, and              BtreeIterator . . . . . . . . . . 55
  containers . . . . . . . . . .  14     Member functions  . . . . . . . 56
  Container implementation . . .  14   Collection  . . . . . . . . . . . 57
  The template solution  . . . .  15     Member functions  . . . . . . . 58
    ADTs and FDSs  . . . . . . .  16   Container . . . . . . . . . . . . 59
    Class templates  . . . . . .  17     Member functions  . . . . . . . 60
  Container class compatibility . 20     Friends . . . . . . . . . . . . 63
  Header files . . . . . . . . .  22   ContainerIterator . . . . . . . . 64
  Tuning an application  . . . .  23     Member functions  . . . . . . . 64
  FDS implementation . . . . . .  24   Date  . . . . . . . . . . . . . . 65
  ADT implementation . . . . . .  27     Member functions  . . . . . . . 65
The class library directory  . .  31   Deque . . . . . . . . . . . . . . 66
  The INCLUDE directory  . . . .  32     Example . . . . . . . . . . . . 67
  The OBJS directory . . . . . .  32     Member functions  . . . . . . . 68
  The SOURCE directory . . . . .  32   Dictionary  . . . . . . . . . . . 69
    Creating a library . . . . .  33     Member functions  . . . . . . . 69
  The LIB directory  . . . . . .  34   DoubleList  . . . . . . . . . . . 70
  The EXAMPLES directory . . . .  34     Member functions  . . . . . . . 71
Preconditions and checks . . . .  35     Friends . . . . . . . . . . . . 73
Container class reference  . . .  36   DoubleListIterator  . . . . . . . 73
AbstractArray  . . . . . . . . .  37     Member functions  . . . . . . . 73
  Data members . . . . . . . . .  37   Error . . . . . . . . . . . . . . 74



                                     i






  Member functions . . . . . . .  75     Member functions  . . . . . . . 92
HashTable  . . . . . . . . . . .  75   Set . . . . . . . . . . . . . . . 92
  Member functions . . . . . . .  76     Member functions  . . . . . . . 92
  Friends  . . . . . . . . . . .  78   Sortable  . . . . . . . . . . . . 93
HashTableIterator  . . . . . . .  78     Member functions  . . . . . . . 95
  Member functions . . . . . . .  78     Related functions . . . . . . . 96
List . . . . . . . . . . . . . .  79   SortedArray . . . . . . . . . . . 97
  Member functions . . . . . . .  79   Stack . . . . . . . . . . . . . . 97
  Friends  . . . . . . . . . . .  80     Example . . . . . . . . . . . . 98
ListIterator . . . . . . . . . .  81     Member functions  . . . . . . . 99
  Member functions . . . . . . .  81   String  . . . . . . . . . . . .  100
MemBlocks  . . . . . . . . . . .  82     Member functions  . . . . . .  100
MemStack . . . . . . . . . . . .  83     Example . . . . . . . . . . .  101
Object . . . . . . . . . . . . .  84   Time  . . . . . . . . . . . . .  102
  Data member  . . . . . . . . .  84     Member functions  . . . . . .  103
  Member functions . . . . . . .  84   Timer . . . . . . . . . . . . .  104
  Friends  . . . . . . . . . . .  87     Member functions  . . . . . .  104
  Related functions  . . . . . .  87   TShouldDelete . . . . . . . . .  105
PriorityQueue  . . . . . . . . .  88     Member functions  . . . . . .  105
  Member functions . . . . . . .  89
Queue  . . . . . . . . . . . . .  90   Index                            107
  Example  . . . . . . . . . . .  91





























                                    ii













Online document
___________________________________________________________________________



                                              The container class libraries


          For more  Turbo C++ version 3.0 includes two complete container
 information about  class libraries: an enhanced version of the Object-
    templates, see  based library supplied with version 1.0, plus a brand-
  Chapter 13, "C++  new implementation based on templates. This chapter
       specifics."  describes both libraries. We assume that you are
                    familiar with the syntax and semantics of C++ and with
                    the basic concepts of object-oriented programming
                    (OOP). To understand the template-based version (called
                    BIDS, for Borland International Data Structures), you
                    should be acquainted with C++'s new template mechanism.

                    The chapter is divided into seven parts:

                    o A review of the difference between versions 1.0 and
                      3.0 of the class libraries
                    o An overview of the Object- and template-based
                      libraries
                    o A survey of the Object container classes, introducing
                      the basic concepts and terminology
                    o An overview of the BIDS library
                    o The CLASSLIB directory and how to use it
                    o Debugging tools
                    o An alphabetic reference guide to the Object container
                      library, listing each class and its members



===========================================================================
What's new since version 1.0?
===========================================================================

                    The version 1.0 container library is an Object-based
                    implementation. Both container objects and the elements
                    stored in them are all ultimately derived from the



                                   - 1 -






                    class Object. Further, the data structures used to
                    implement each container class were fixed and (usually)
                    hidden from the programmer. This provides a simple,
                    effective model for most container applications.
                    Version 3.0 therefore offers an enhanced, code-
                    compatible version of the previous Object-based
                    container library. We call this the Object container
                    class library. In addition, a more flexible (but more
                    complex), template-based container library, called BIDS
                    (Borland International Data Structures), is supplied
                    with version 3.0. Through the power of templates, BIDS
                    lets you vary the underpinning data structure for a
                    container and lets you store arbitrary objects in a
                    container. With the appropriate template parameters,
                    BIDS can actually emulate the Object container library.

                    Before we review the differences between the Object and
                    BIDS models, we'll list the changes to the Object
                    container library since version 1.0:

                    o New Btree and PriorityQueue classes.
                    o New TShouldDelete class gives the programmer control
                      over container/element ownership. You can control the
                      fate of objects when they are detached from a
                      container and when the container is flushed (using
                      the new flush method) or destroyed.
                    o New memory management classes, MemBlocks and
                      MemStack, for efficient memory block and memory stack
                      (mark-and-release) allocations.
                    o New PRECONDITION and CHECK macros provide sophisti-
                      cated assert mechanisms to speed application develop-
                      ment and debugging.
                    o New Timer class gives you a stopwatch for timing
                      program execution.

   When you choose  Existing Turbo C++ version 1.01 container class code
   Container Class  will still run with the version 3.0 libraries. The new
    Library in the  Object container class libraries, in directory
    IDE's Options|  \CLASSLIB, are distinguished by the prefix TC:
  Linker|Libraries  TCLASSx.LIB and TCLASDBx.LIB where x specifies the
   dialog box, the  memory model, and DB indicates the special debug
      Object-based  version. To reduce verbiage, we will often refer to
 libraries will be  this container implementation as the Object or TC
     automatically  version.
        linked in.






                                   - 2 -






        To use the  The corresponding libraries for the new template-based
    template-based  container classes are distinguished by the prefix BIDS:
    libraries, you  BIDSx.LIB and BIDSDBx.LIB. Let's review the reasons for
   must explicitly  having two sets of container libraries. The use of all
           add the  these libraries is covered on page 31.
       appropriate
     BIDS[DB]x.LIB
   library to your
        project or
         makefile.



===========================================================================
Why two sets of libraries?
===========================================================================

                    The Object container classes have been retained and
                    enhanced to provide code compatibility with the version
                    1.0 library. They provide a gentler learning curve than
                    the template-based BIDS library. The Object container
                    code offers faster compilation but slightly slower
                    execution than the template version. The project files
                    for the example and demo programs are set up to use the
                    Object version of the container libraries.

                    BIDS exploits the new exciting templates feature of C++
                    2.1. It offers you considerable flexibility in choosing
                    the best underlying data structure for a given
                    container application. With the Object version, each
                    container is implemented with a fixed data structure,
                    chosen to meet the space/speed requirements of most
                    container applications. For example, a Bag object is
                    implemented with a hash table, and a Deque object with
                    a double list. With BIDS you can fine-tune your
                    application by varying the container implementation
                    with the minimum recoding--often a single typedef will
                    suffice. You can switch easily from StackAsList to
                    StackAsVector and test the results. In fact, you'll see
                    that by setting appropriate values for <T>, a generic
                    class parameter, you can implement the Object model
                    exactly. With BIDS, you can even choose between
                    polymorphic and non-polymorphic implementations of the
                    Object container model. Such choices between execution
                    speed (non-polymorphic) and future flexibility
                    (polymorphic) can be tested without major recoding.





                                   - 3 -






     Existing code  Both the Object and BIDS versions provide the same
      based on the  functional interface. For example, the push and pop
  Object container  member functions work the same for all Stack objects.
      classes will  This makes the new template-based libraries highly
   compile and run  compatible with existing code written for the Object
   perfectly using  library.
      the new BIDS
  classes, just by  The objects stored in Object library containers must be
    linking in the  derived from the class Object. To store ints, say, you
       appropriate  would have to derive an Integer class from Object
          library.  (you'll see how later). With BIDS you have complete
                    freedom and direct control over the types of objects
                    stored in a container. The stored data type is simply a
                    value passed as a template parameter. For instance,
                    BI_ListImp<int> gives you a list of ints.

                    Regardless of which container class model you elect to
                    use, you should be familiar with container terminology,
                    the Object class hierarchy, and the functionality
                    provided for each container type. Although the classes
                    in the BIDS library have different naming conventions
                    and special template parameters, the prototypes and
                    functionality of each class member are the same as
                    those in the Object library.



===========================================================================
Container basics
===========================================================================

  If you are fully  We start by describing the Object container class
     versed in the  hierarchy as enhanced for Turbo C++ version 3.0. This
     Turbo C++ 1.0  hierarchy offers a high degree of modularity through
    version of the  inheritance and polymorphism. You can use these classes
container library,  as they are, or you can extend and expand them to pro-
  you should first  duce an object-oriented software package specific to
     check out the  your needs.
    Object library
      enhancements  At the top of the class hierarchy is the Object class
  before moving to  (see Figure 1), an abstract class that cannot be
     the templates  instantiated (no objects of its type can be declared).
   section on page  An abstract class serves as an umbrella for related
               14.  classes. As such, it has few if any data members, and
                    some or all of its member functions are pure virtual
                    functions. Pure virtual functions serve as placeholders
                    for functions of the same name and signature intended




                                   - 4 -






                    to be defined eventually in derived classes. In fact,
                    any class with at least one pure virtual function is,
                    by definition, an abstract class.

Figure 1: Class hierarchies in CLASSLIB

ObjectÄÂÄError
       ÃÄSortableÄÄÄÄÂÄString
       ³             ÃÄBaseDateÄÄÄÄÄDate
       ³             ÀÄBaseTimeÄÄÄÄÄTime
       ÃÄAssociation
       ÀÄContainerÄÄÄÂÄCollectionÄÂÄAbstractArrayÄÂÄArray
                     ³            ³               ÀÄSortedArray
                     ³            ÃÄHashTable
                     ³            ÃÄBagÄÄSetÄÄDictionary
                     ³            ÃÄList
                     ³            ÃÄBtree
                     ³            ÀÄDoubleList
                     ÃÄStack
                     ÃÄDequeÄÄQueue
                     ÀÄPriorityQueue
ContainerIteratorÄÄÄÄÂÄHashTableIterator
                     ÃÄListIterator
                     ÃÄDoubleListIterator
                     ÃÄBtreeIterator
                     ÀÄArrayIterator
Memblocks
MemStack
                    Note that TShouldDelete provides a second base
                    (multiple inheritance) for both Container and
                    Association.

                    A class derived from an abstract class can provide a
                    body defining the inherited pure virtual function. If
                    it doesn't, the derived class remains abstract,
                    providing a base for further derivations. When you
                    reach a derived class with no pure virtual functions,
                    the class is called a non-abstract or instance class.
                    As the name implies, instance classes can be
                    instantiated to provide usable objects.

                    An abstract class can be the base for both abstract and
                    instance classes. For example, you'll see that
                    Container, an abstract class derived from the abstract
                    class Object, is the base for both Collection
                    (abstract) and Stack (instance).





                                   - 5 -






   To enhance your  As you read this chapter, bear in mind that a derived
  understanding of  class inherits and can access all non-private data
  the classes, you  members and member functions from all its ancestral
  can review their  base classes. For example, the Array class does not
   declarations in  need to explicitly define a function to print an array,
   the source code  because its immediate parent class AbstractArray does
      files in the  so. The Container class, an ancestor further up the
          CLASSLIB  class tree, defines a different print function that can
        directory.  also be used with an array, because an array is a
                    container. To determine all the member functions
                    available to an object, you will have to ascend the
                    class hierarchy tree. Because the public interface is
                    intended to be sufficient for applications, object-
                    oriented programming makes a knowledge of private data
                    members unnecessary; therefore, private members (with a
                    few exceptions) are not documented in this chapter.


------------------  The Object-based hierarchy contains classes derived
  Object-based and  from the class Object (together with some other utility
     other classes  classes). Object provides a minimal set of members
------------------  representing what every derived object must do; these
                    are described in the reference section under Object
                    (page 84). Both the containers-as-objects and the
                    objects they store are objects derived (ultimately)
                    from Object. Later you'll see that the template-based
                    containers can contain objects of any data type, not
                    just those derived from Object.

  Class categories  =======================================================

                    The classes in or near the Object hierarchy can be
                    divided into three groups:

                    o The non-container classes include Object itself, and
                      those classes derived from Object, such as String and
                      Date, which cannot store other objects.
                    o The container classes (also derived from Object),
                      such as Array and List, which can store objects of
                      other, usually non-container, class types.
                    o The helper and utility classes not derived from
                      Object, such as TShouldDelete, ListIterator and
                      MemStack.

                    Let's look at each category in more detail, although as
                    with most OOP topics, they are closely related.





                                   - 6 -






     Non-container  =======================================================
           classes
                    The basic non-container classes provided are Object and
                    its three children: Error (instance), Sortable
                    (abstract), and Association (instance). Recall that the
                    main purpose of these classes is to provide objects
                    that can be stored as data elements in containers. To
                    this end, all Object-derived classes provide a hashing
                    function allowing any of their objects to be stored in
                    a hash table.

------------------  Error is not a normal class; it exists solely to define
       Error class  a unique, special object called theErrorObject. A
------------------  pointer to theErrorObject carries the mnemonic
 Error see page 74  NOOBJECT. NOOBJECT is rather like a null pointer, but
  in the reference  serves the vital function of occupying empty slots in a
          section.  container. For example, when an Array object is created
                    (not to be confused with a traditional C array), each
                    of its elements will initially contain NOOBJECT.

------------------  Sortable is an abstract class from which sortable
    Sortable class  classes must be derived. Some containers, known as
------------------  ordered collections, need to maintain their elements in
                    a particular sequence. Collections such as SortedArray
                    and PriorityQueue, for example, must have consistent
                    methods for comparing the "magnitude" of objects.
                    Sortable adds the pure virtual function isLessThan to
                    its base, Object. Classes derived from Sortable need to
                    define IsLessThan and IsEqual (inherited from Object)
                    for their particular objects. Using these members, the
                    relational operators <, ==, >, >=, and so on, can be
                    overloaded for sortable objects. Typical sortable
                    classes are String, Date, and Time, the objects of
                    which are ordered in the natural way. Of course, string
                    ordering may depend on your locale, but you can always
                    override the comparison functions (another plus for
                    C++).

  For more details  Distinguish between the container object and the
   on Sortable see  objects it contains: Sortable is the base for non-
    page 93 in the  container objects; it is not a base for ordered
reference section.  collections. Every class derived from Object inherits
                    the isSortable member function so that objects can be
                    queried as to their "sortability."







                                   - 7 -






------------------  Association is a non-container, instance class
 Association class  providing special objects to be stored (typically) in
------------------  Dictionary collections. An Association object, known as
   Association see  an association, is a pair of objects known as the key
    page 44 in the  and the value. The key (which is unique in the
reference section.  dictionary) can be used to retrieve the value. Every
                    class derived from Object inherits the isAssociation
                    member function so that objects can report whether they
                    are associations or not.

 Container classes  =======================================================

                    In the Object-based library, all the container storage
                    and access methods assume that the stored elements are
                    derived from Object. They are actually stored as
                    references or pointers to Object offering the
                    advantages and disadvantages of polymorphism. Most of
                    the container access member functions are virtual, so a
                    container does not need to "know" how its contained
                    elements were derived. A container can, in theory,
                    contain mixed objects of different class types, so
                    proper care is needed to maintain type-safe linkage.
                    Every class has member functions called IsA and nameOf,
                    which allow objects to announce their class ID and
                    name. As you've seen, there are also isSortable and
                    isAssociation member functions for testing object
                    types.

                    All the container classes are derived from the abstract
                    Container class, a child of Object. Container
                    encapsulates just a few simple properties upon which
                    more specialized containers can be built. The basic
                    container provides the following functionality:

                    o Displays its elements
                    o Calculates its hash value
                    o Pure virtual slot for counting the number of items
                      with getItemsInContainer
                    o Pure virtual slot for flushing (emptying) the
                      container with flush
                    o Performs iterations over its elements
                    o Reports and changes the ownership of its elements
                      (inherited from TShouldDelete)

                    So far, our containers have no store, access, or detach
                    methods. (We can flush the container but we cannot
                    detach individual elements.) Nor is there a hasMember




                                   - 8 -






                    member function, that is, a general way of determining
                    whether a given object is an element of the container.
                    This is a deliberate design decision. As we move up the
                    hierarchy, you'll see that what distinguishes the
                    various derived container classes are the storage and
                    access rules that actually define each container's
                    underlying data structure. Thus push and pop member
                    functions are added for Stack, indexing operators are
                    added for Array, and so on. There is not enough in
                    common to warrant having generic add and retrieve
                    methods at the Container level. There is no one perfect
                    way of extracting common properties from groups of
                    containers, and therefore no perfect container class
                    hierarchy. The Object-based container hierarchy is just
                    one possible design based on reasonable compromises.
                    The BIDS version, as you'll see, offers a different
                    perspective.

                    The first three Container functions listed previously
                    are fairly self-explanatory. We'll discuss the
                    important subjects of ownership and iteration in the
                    next two sections.


    Containers and  =======================================================
         ownership
                    Before you use the Container family, you must
                    understand the concept of ownership. As in real life, a
                    C++ container starts out empty and must be filled with
                    objects before the objects can be said to be in the
                    container. Unlike the real world, however, when objects
                    are placed in the container, they are, by default,
                    owned by the container. The basic idea is that when a
                    container owns its objects, the objects are destroyed
                    when the container is destroyed.

                    Recall that containers are themselves objects subject
                    to the usual C++ scoping rules, so local containers
                    come and go as they move in and out of scope. Care is
                    needed, therefore, to prevent unwanted destruction of a
                    container's contents, so provision is made for changing
                    ownership. A container can, throughout its lifetime,
                    relinquish and regain ownership of its objects as often
                    as it likes by calling the ownsElements member function
                    (inherited from TShouldDelete). The fate of its objects
                    when the container disappears is determined by the
                    ownership status ruling at the time of death. Consider
                    the following:



                                   - 9 -






                     void test()
                     {
                       Array a1( 10 );    // construct an array
                       Array a2( 10 );    // and another

                       a1.ownsElements( 1 );  // array a1 owns its objects
                                                 (the default)
                       a2.ownsElements( 0 );  // array a2 relinquishes
                                                 ownership

                       // load and manipulate the arrays here

                     }

                    When test exits, a1 will destroy its objects, but the
                    objects in a2 will survive (subject, of course, to
                    their own scope). The a1.ownsElements( 1 ) call is not
                    really needed since, by default, containers own their
                    contents.

                    Ownership also plays a role when an object is removed
                    from a container. The pure virtual function
                    Container::flush is declared as

                       virtual void flush( DeleteType dt = DefDelete ) = 0;

                    flush empties the container but whether the flushed
                    objects are destroyed or not is controlled by the dt
                    argument. DeleteType is an enum defined in
                    TShouldDelete. A value of NoDelete means preserve the
                    flushed objects regardless of ownership; Delete means
                    destroy the objects regardless of ownership; DefDelete,
                    the default value, means destroy the objects only if
                    owned by the container. Similarly Collection (derived
                    from Container) has a detach member function, declared
                    as

                       virtual void detach( Object& obj, DeleteType dt =
                       NoDelete ) = 0;

                    which looks for obj in the collection and removes it if
                    found. Again, the fate of the detached object is
                    determined by the value dt. Here, the default is not to
                    destroy the detached object. Collection::destroy is a
                    variant that calls detach with DefDelete.

                    A related problem occurs if you destroy an object that
                    resides in a container without "notifying" the



                                  - 10 -






                    container. The safest approach is to use the
                    container's methods to detach and destroy its contents.

        Important!  If you declare an automatic object (an object that's
                    local to your routine) and place that object in a
                    global container, your local object will be destroyed
                    when the routine leaves the scope in which it was
                    declared. To prevent this, you must only add heap
                    objects (objects that aren't local to the current
                    scope) to global containers. Similarly, when you remove
                    an object from a global container, you are responsible
                    for destroying it and freeing the space in which it
                    resides.


         Container  =======================================================
         iterators
                    You saw earlier that Container, the base for all
                    containers in the Object-based library, supports
                    iteration. Iteration means traversing or scanning a
                    container, accessing each stored object in turn to
                    perform some test or action. The separate
                    ContainerIterator-based hierarchy provides this
                    functionality. Iterator classes are derived from this
                    base to provide iterators for particular groups of
                    containers, so you'll find HashTableIterator,
                    ListIterator, BtreeIterator, and so on.

             Under  There are two flavors of iterators: internal and
 ContainerIterator  external. Each container inherits the three member
 on page 64 in the  functions: firstThat, lastThat, and forEach, via the
reference section,  Object and Container classes. As the names indicate,
   you see how the  these let you scan through a container either testing
    pre- and post-  each element for a condition or performing an action on
         increment  each of the container's elements. When you invoke one
  operators ++ are  of these three member functions, the appropriate
     overloaded to  iterator object is created for you internally to
     simplify your  support the iteration. Most iterations can be performed
iterator programs.  in this way since the three iterating functions are
                    very flexible. They take a pointer-to-function argument
                    together with an arbitrary parameter list, so you can
                    do almost anything. For even more flexibility, there
                    are external iterators that you can build via the
                    initIterator member function. With these, you have to
                    set up your own loops and test for the end-of-
                    container.





                                  - 11 -






                    Returning to the container class hierarchy, we look at
                    three classes derived directly from Container: Stack,
                    Deque, and PriorityQueue.


  Sequence classes  =======================================================

                    The instance classes Stack, Deque (and its offspring
                    Queue), and PriorityQueue are containers collectively
                    known as sequence classes. A sequence class is
                    characterized by the following properties:

                    1. Objects can be inserted and removed.

                    2. The order of insertions and deletions is
                       significant.

                    3. Insertions and extractions can occur only at
                       specific points, as defined by the individual class.
                       In other words, access is nonrandom and restricted.

                    Sequences (like all containers) know how many elements
                    they have (using getItemsInContainer) and if they are
                    empty or not (using isEmpty). However, they cannot
                    usually determine if a given object is a member or not
                    (there is still no general hasMember or findMember
                    member function). Stacks, queues, priority queues, and
                    deques vary in their access methods as explained in
                    more detail in the reference section.

                    Sequence is not itself a class because sequences do not
                    share enough in common to warrant a separate base
                    class. However, you might find it helpful to consider
                    the classes together when reviewing the container
                    hierarchy.


       Collections  =======================================================

                    The next level of specialization is the abstract class
                    Collection, derived from Container, and poised to
                    provide a slew of widely used data structures. The key
                    difference between collections and containers  is that
                    we now have general hasMember and findMember member
                    functions.

                    From Collection we derive the unordered collections
                    Bag, HashTable, List, DoubleList, and AbstractArray,



                                  - 12 -






                    and the ordered collection Btree. In turn,
                    AbstractArray spawns the unordered Array and the
                    ordered SortedArray. Bag serves as the base for Set
                    which in turn is the base for Dictionary. These
                    collections all refine the storage and retrieval
                    methods in their own fashions.


------------------  With unordered collections, any objects derived from
         Unordered  Object can be stored, retrieved, and detached. The
       collections  objects do not have to be sortable because the access
------------------  methods do not depend on the relative "magnitude" of
                    the elements. Classes that fall into this category are

                    o HashTable
                    o Bag, Set, and Dictionary
                    o List and DoubleList
                    o Array


------------------  An ordered collection depends on relative "magnitude"
           Ordered  when adding or retrieving its elements. Hence these
       collections  elements must be objects for which the isLessThan
------------------  member function is defined. In other words, the
                    elements in an ordered collection must be derived from
                    the class Sortable. The following are ordered
                    collections:

                    o Btree
                    o SortedArray



===========================================================================
The BIDS template library
===========================================================================

                    The BIDS container class library can be used as a
                    springboard for creating useful classes for your
                    individual needs. Unlike the Object container library,
                    BIDS lets you fine-tune your applications by varying
                    the underlying data structures for different containers
                    with minimum reprogramming. This extends the power of
                    encapsulation: the implementor can change the internals
                    of a class with little recoding and the user can easily
                    replace a class with one that provides a more
                    appropriate algorithm. The BIDS class library achieves
                    this flexibility by using the C++ template mechanism.



                                  - 13 -






       For a basic  With BIDS, the container is considered as an ADT
description of C++  (abstract data type), and its underlying data structure
     templates see  is independently treated as an FDS (fundamental data
       Chapter 13.  structure). BIDS also allows separate selections of the
                    type of objects to be stored, and whether to store the
                    objects themselves or pointers to objects.

        Templates,  =======================================================
      classes, and
        containers  Computer science has devoted much attention to devising
                    suitable data structures for different applications.
                    Recall Wirth's equation, Programs = Algorithms + Data
                    Structures, which stresses the equal importance of data
                    structures and their access methods.

                    As used in current OOP terminology, a container is
                    simply an object that implements a particular data
                    structure, offering member functions for adding and
                    accessing its data elements (usually other objects)
                    while hiding from the user as much of the inner detail
                    as possible. There are no simple rules to determine the
                    best data structure for a given program. Often, the
                    choice is a compromise between competing space (RAM)
                    and time (accessibility) considerations, and even here
                    the balance can shift suddenly if the number of
                    elements or the frequency of access grows or falls
                    beyond a certain number.


         Container  =======================================================
    implementation
                    Often, you can implement the desired container
                    properties in many ways using different underlying data
                    structures. For example, a stack, characterized by its
                    Last-In-First-Out (LIFO) access, can be implemented as
                    a vector, a linked list, or perhaps some other
                    structure. The vector-based stack is appropriate when
                    the maximum number of elements to be stored on the
                    stack is known in advance. A vector allocates space for
                    all its elements when it is created. The stack as a
                    list is needed when there is no reasonable upper bound
                    to the size of the stack. The list is a slower imple-
                    mentation than the vector, but it doesn't use any more
                    memory than it needs for the current state of the
                    stack.






                                  - 14 -






                    The way objects are stored in the container also
                    affects size and performance: they can be stored
                    directly by copying the object into the data structure,
                    or stored indirectly via pointers. The type of data to
                    be stored is a key factor. A stack of ints, for
                    example, would probably be stored directly, where large
                    structs would call for indirect storage to reduce
                    copying time. For "in-between" cases, however, choosing
                    strategies is not always so easy. Performance tuning
                    requires the comparison of different container
                    implementations, yet traditionally this entails drastic
                    recoding.


      The template  =======================================================
          solution
                    The template approach lets you develop a stack-based
                    application, say, using vectors as the underlying
                    structure. You can change this to a list implementation
                    without major recoding (a single typedef change, in
                    fact). The BIDS library also lets you experiment with
                    object-storage strategies late in the development
                    cycle. Each container-data structure combination is
                    implemented with both direct and indirect object
                    storage, and the template approach allows a switch of
                    strategy with minimal rewriting. The data type of the
                    stored elements is also easy to change using template
                    parameters, and you are free to use any data type you
                    want.

                    As you'll see, BIDS offers container/data structure
                    combinations that match those of the Object-based
                    version. For example, the Object library implements
                    Stack using lists, so Stack can be simulated exactly
                    with the template class BI_TCStackAsList. Let's look at
                    the template approach in more detail.















                                  - 15 -






------------------  We discussed earlier the stack and its possible
     ADTs and FDSs  implementations as a linked list or as a vector. The
------------------  potential for confusion is that stacks, lists, and
                    vectors are all commonly referred to as data
                    structures. However, there is a difference. We can
                    define a stack abstractly in terms of its LIFO
                    accessibility, but it's difficult to envision a list
                    without thinking of specifics such as nodes and
                    pointers. Likewise, we picture a vector as a concrete
                    sequence of adjacent memory locations. So we call the
                    stack an ADT (abstract data type) and we call the list
                    and vector FDSs (fundamental data structures). The BIDS
                    container library offers each of the standard ADTs
                    implemented with a choice of appropriate FDSs. Table 1
                    indicates the combinations provided:

         ADTs as
fundamental data    -------------------------------------------------------
      structures                                      ADT              Sorted
                    FDS          Stack  Queue  Deque  Bag  Set  Array  Array
                    -------------------------------------------------------

                    Vector       x      x      x      x    x    x      x
                    List         x
                    DoubleList          x      x

                    -------------------------------------------------------

                    The abstract data types involved are Stacks, Queues,
                    Deques, Bags, Sets, and Arrays. Each ADT can be
                    implemented several different ways using the
                    fundamental data structures Vector, List, and
                    DoubleList as indicated by a bullet ( x ) in the table.
                    Thus, all ADTs are implemented as vectors. In addition,
                    Stacks are implemented as a list; Queues and Deques
                    implemented as doubly-linked lists. (Not shown in the
                    table are the sorted and counted FDSs from which
                    various ADTs can be developed.)

                    There is nothing sacred about these combinations; you
                    can use the template classes to develop your own
                    ADT/FDS implementations.









                                  - 16 -






------------------  ADTs are implemented in both direct and indirect
   Class templates  versions. The direct versions store the objects
------------------  themselves, while the indirect versions store pointers
                    to objects. You can store whatever objects you want as
                    elements in these FDSs using the power of templates.
                    Here are the ADT and FDS templates we provide:


---------------------------------------------------------------------------
Table 2: FDS class templates

Class template              Description
---------------------------------------------------------------------------

BI_VectorImp<T>             vector of Ts
BI_VectorIteratorImp<T>     iterator for a vector of Ts
BI_CVectorImp<T>            counted vector of Ts
BI_SVectorImp<T>            sorted vector of Ts
BI_IVectorImp<T>            vector of pointers to T
BI_IVectorIteratorImp<T>    iterator for a vector of pointers to T
BI_ICVectorImp<T>           counted vector of pointers to T
BI_ISVectorImp<T>           sorted vector of pointers to T
BI_ListImp<T>               list of Ts
BI_SListImp<T>              sorted list of Ts
BI_IListImp<T>              list of pointers to T
BI_ISListImp<T>             sorted list of pointers to T
BI_DoubleListImp<T>         double-linked list of Ts
BI_SDoubleListImp<T>        sorted double-linked list of Ts
BI_IDoubleListImp<T>        double-linked list of pointers to T
BI_ISDoubleListImp<T>       sorted double-linked list of pointers to T

---------------------------------------------------------------------------

                    Each basic FDT has a direct and indirect iterator; to
                    save space we have shown only the Vector iterators.

                    The BI_ prefix stands for Borland International and the
                    suffix Imp for implementation. The indirect versions
                    have the prefix BI_I with the extra I for Indirect. The
                    extra prefixes S and C mean Sorted and Counted
                    respectively. The template parameter T in <T>
                    represents the data type of the objects to be stored.
                    You instantiate the template by supplying this data
                    type. For example, BI_ListImp<double> gives you a list
                    of doubles. See Table 3 on page 19 for a summary of
                    these abbreviations. For direct object storage, the





                                  - 17 -






                    type T must have meaningful copy semantics and a
                    default constructor. Indirect containers, however, hold
                    pointers to T, and pointers always have
















































                                  - 18 -






                    good copy semantics. This means that indirect
                    containers can contain objects of any type.

Abbreviations in
  CLASSLIB names    -----------------------------------------------------------------
                    Abbreviation       Description
                    -----------------------------------------------------------------

                      I                Indirect
                      C                Counted
                      S                Sorted
                      O                Object-based, non-polymorphic
                      TC               Object-based, polymorphic (compatible with
                                       original Turbo C++ library)

                    -----------------------------------------------------------------

   For details see  For the sorted FDSs (BI_SVectorImp, BI_ISVectorImp, and
    the discussion  so on), T must have valid == and < operators to define
 under Sortable on  the ordering of the elements. It should be clear that
          page 94.  the IS variants refer to the objects being sorted, not
                    that the pointers to the objects are sorted.

                    Each implementation of an ADT with an FDS is named
                    using the convention (ADT)As(FDS)<T>, as follows:


----------------------------------------------------------------------------
Table 4: ADT class templates

Class name                    Description
----------------------------------------------------------------------------

BI_StackAsVector<T>           Stack of Ts as a vector
BI_QueueAsVector<T>           Queue of Ts as a vector
BI_DequeAsVector<T>           Deque of Ts as a vector
BI_BagAsVector<T>             Bag of Ts as a vector
BI_SetAsVector<T>             Set of Ts as a vector
BI_ArrayAsVector<T>           Array of Ts as a vector
BI_SArrayAsVector<T>          Sorted array of Ts as a vector

BI_IStackAsVector<T>          Stack of pointers to T as a vector
BI_IQueueAsVector<T>          Queue of pointers to T as a vector

...                           and so on

BI_StackAsList<T>             Stack of Ts as a list
BI_IStackAsList<T>            Stack of pointers to T as a list



                                  - 19 -






Table 4: ADT class templates (continued)___________________________________

BI_QueueAsDoubleList<T>       Queue of Ts as a double list
BI_DequeAsDoubleList<T>       Deque of Ts as a double list
BI_IQueueAsDoubleList<T>      Queue of pointers to T as a double list
BI_IDequeAsDoubleList<T>      Deque of pointers to T as a double list

----------------------------------------------------------------------------

    There are also  Again, the <T> argument, either a class or predefined
       BI_Oxxx and  data type, provides the data type for the contained
 BI_TCxxx variants  elements. Each of the bulleted items ( x ) in Table 1
   discussed soon.  can be mapped to two templates (direct and indirect
                    versions) with names following this convention.


   Container class  ========================================================
     compatibility
                    Each template must be instantiated with a particular
                    data type as the type of the element that it will hold.
                    This allows the compiler to generate the correct code
                    for dealing with any possible type of element without
                    restricting the elements to just those derived from
                    Object.

                    Each ADT is also used to instantiate two classes that
                    imitate the behavior of the Object class libraries. Here
                    is a list of them:


                    --------------------------------------------------------
Object-based FDS    Class name                Description
         classes    --------------------------------------------------------

                    BI_OStackAsVector         Stack of pointers to Object,
                                              as a vector
                    BI_OQueueAsVector         Queue of pointers to Object,
                                              as a vector
                    BI_ODequeAsVector         Deque of pointers to Object,
                                              as a vector
                    BI_OBagAsVector           Bag of pointers to Object, as
                                              a vector
                    BI_OSetAsVector           Set of pointers to Object, as
                                              a vector
                    BI_OArrayAsVector         Array of pointers to Object,
                                              as a vector
                    BI_OSArrayAsVector        Sorted array of pointers to
                                              Object, as a vector



                                  - 20 -






                    Table 5: Object-based FDS classes (continued)__________

                    BI_TCStackAsVector        Polymorphic stack of pointers
                                              to Object, as a vector
                    BI_TCQueueAsVector        Polymorphic queue of pointers
                                              to Object, as a vector
                    BI_TCDequeAsVector        Polymorphic deque of pointers
                                              to Object, as a vector
                    BI_TCBagAsVector          Polymorphic bag of pointers to
                                              Object, as a vector
                    BI_TCSetAsVector          Polymorphic set of pointers to
                                              Object, as a vector
                    BI_TCArrayAsVector        Polymorphic array of pointers
                                              to Object, as a vector
                    BI_TCSArrayAsVector       Polymorphic sorted array of
                                              pointers to Object, as a
                                              vector

                    BI_OStackAsList           Stack of pointers to Object,
                                              as a list
                    BI_TCStackAsList          Polymorphic stack of pointers
                                              to Object, as a list

                    BI_OQueueAsDoubleList     Queue of pointers to Object,
                                              as a double list
                    BI_ODequeAsDoubleList     Deque of pointers to Object,
                                              as a double list

                    BI_TCQueueAsDoubleList    Polymorphic queue of pointers
                                              to Object, as a double list
                    BI_TCDequeAsDoubleList    Polymorphic deque of pointers
                                              to Object, as a double list

                    --------------------------------------------------------

                    Note that these versions have no explicit <T>
                    parameters; they use the fixed data types shown
The TCxxx versions  (pointers to Object). The BI_Oxxx (O for Object library)
    offer the same  versions of these classes have no virtual functions.
      behavior and  This makes it easier for the compiler to generate inline
 interfaces as the  function expansions, which in turn makes the BI_Oxxx
   Object library.  versions of the containers somewhat faster than the
                    corresponding polymorphic BI_TCxxx (TC for Turbo C++)
                    versions. The obverse of the coin is that the BI_Oxxx
                    versions do not share the polymorphic behavior of the
                    Object container library.





                                  - 21 -






                    In the Object container library, Stack implements a
                    stack as a polymorphic list of pointers to Object. The
                    BIDS class BI_TCStackAsList therefore mirrors the
                    Object-based class Stack. Even with BI_TCStackAsVector,
                    the public interface and semantics are the same as for
                    the Object-based Stack. The user "sees" the ADT while
                    the FDS is "hidden." For these reasons, we will not
                    repeat the alphabetic list of Object-based classes and
                    member functions for the BIDS library.

                    Consider your many choices when writing container code
                    with the BIDS model. You can gain speed over future
                    flexibility by using the non-polymorphic classes, such
                    as BI_OStackAsList or BI_OStackAsVector. Or you can
                    retain the polymorphism of the Object-based hierarchy by
                    using the BI_TCxxx classes.


      Header files  ========================================================

                    Each group of FDSs is defined in its own header file,
                    which contains templates for both the direct and the
                    indirect versions. The names of the headers are as
                    follows:

                      vectimp.h
                      listimp.h
                      dlistimp.h

                    In vectimp.h, for example, you'll find declarations for
                    all the vector, counted vector, and sorted vector
                    templates, together those for a direct and indirect
                    vector iterator.

                    Note also the stdtempl.h file that defines the useful
                    template functions min, max, and range. If you are new
                    to templates, this file offers a useful, gentle
                    introduction to the subject.

                    Each ADT family is defined in its own header file, named
                    as follows:

                      stacks.h
                      queues.h
                      deques.h
                      bags.h
                      sets.h
                      arrays.h



                                  - 22 -






   Note the plural  The file stacks.h, for example, defines the following
         form that  templates:
 distinguishes the
BIDS include files   BI_StackAsVector<T>
  from the Object-   BI_IStackAsVector<T>
based include file   BI_OStackAsVector
                     BI_TCStackAsVector
                     BI_StackAsList<T>
                     BI_IStackAsList<T>
                     BI_OStackAsList
                     BI_TCStackAsList


         Tuning an  ========================================================
       application
                    Consider the following example:

                     typedef BI_StackAsVector<int> intStack;

                     int main()
                     {
                       intStack is;
                       for( int i = 0; i < 10; i++ )
                         is.push( i );
                       for( i = 0; i < 10; i++ )
                         cout << is.pop() << endl;
                       return(0);
                     }

                    Here we are implementing a stack of ints using a vector
                    as the underlying data structure. If you later determine
                    that a list would be a more suitable implementation for
                    the stack, you can simply replace the typedef with the
                    following:

                        typedef BI_StackAsList<int> intStack;

                    After recompilation, the stack implementation is changed
                    from vector to list. Similarly, you can try a stack of
                    pointers to int, with:

                        typedef BI_IStackAsList<int> intStack;









                                  - 23 -






FDS implementation  ========================================================

                    Each FDS is implemented as two templates, one that
                    provides the direct version, and one that provides the
                    indirect version. The indirect version makes use of an
                    InternalIxxxImp class. The following simplified extract
                    from listimp.h will give you an idea how the different
                    list FDSs are implemented. Note that BI_ListElement<T>
                    is an internal template class used to implement the node
                    (data of type T and pointer to next node) of a list. The
                    direct list of objects of type T is implemented by the
                    template class BI_ListImp<T>, which also provides the
                    base for BI_SListImp<T> (sorted lists). The example
                    shows how the add member function is implemented in the
                    direct, indirect, sorted and unsorted lists.

                     template <class T> class BI_ListElement
                     {
                     public:
                       BI_ListElement( T t, BI_ListElement<T> *p ) : data(t)
                         { next = p->next; p->next = this; }
                     // constructor
                     ...
                       BI_ListElement<T> *next;    // pointer to next node
                       T data;                     // object at node
                     ...
                     };

                     template <class T> class BI_ListImp
                     // linked list (unsorted) of type T objects; assumes T
                     has meaningful // copy semantics and a default
                     constructor
                     {
                     public:
                     ...
                       void add( T t ) { new BI_ListElement<T>( t, &head );
                     }
                     // adds objects at head of list (shown inline here to
                     save space)
                       T peekHead() const { return head.next->data; }
                     ...
                     };

                     template <class T> class BI_SListImp : public
                     BI_ListImp<T>
                     // sorted list; assumes T has meaningful copy





                                  - 24 -






                     // semantics and a default constructor
                     {
                     public:
                     ...
                       void add( T t ) { new BI_ListElement<T>( t,
                     findPred(t) ); }
                     // adds object in sorted position
                     ...
                     };

                     template <class T, class List> class
                     BI_InternalIListImp : public List
                     {
                     ...
                       void add( T *t ) { List::add ( t ); }
                     };
                     // The work is done in this intermediate class
                     // used as base for BI_IListImp; list is
                     // unsorted so we use List::add

                     template <class T> class BI_IListImp :
                     public BI_InternalIListImp<T, BI_ListImp< void * > >
                     { ... };
                     /* unsorted list of pointers to objects of type T;
                        since pointers always have meaningful copy
                        semantics, this class can handle any object type;
                        add comes straight from BI_InternalIListImp
                     */

                     template <class T> class BI_ISListImp :
                     public BI_InternalIListImp<T>, BSListImp< void * >> {
                     ... };
                     /* sorted list of pointers to objects of type T; since
                        pointers always have meaningful copy semantics, this
                        class can handle any object type
                     */

                    In addition to the template classes shown here,
                    listimp.h also declares BI_ListIteratorImp<T> and
                    BI_IListIteratorImp<T>, the iterators for direct and
                    indirect lists.

                    In the next section on ADTs, you'll see how the
                    different stack implementations in stacks.h pull in the
                    vector and list FDSs declared in vectimp.h and
                    listimp.h.





                                  - 25 -






                    The double list templates, in dlistimp.h, follows the
                    same pattern. The sorted versions of list and double
                    list provide exactly the same interface as the non-
                    sorted ones, except that the add member function adds
                    new elements in sorted order. This speeds up subsequent
                    access and also makes it easier to implement priority
                    queues.

                    vectimp.h also follows a similar pattern to listimp.h,
                    implementing BI_VectorImp<T> (direct) and
                    BI_IVectorImp<T> (indirect). These are low-level vectors
                    with no notion of add or detach. To support more
                    sophisticated ADTs, the counted vector,
                    BI_CVectorImp<T>, derived from BI_VectorImp<T>, is
                    provided. This maintains a pointer to the last valid
                    entry in the underlying Vector. It has an add member
                    function that inserts its argument at the top (the next
                    available slot), and a detach member function that
                    removes its argument and compresses the array.
                    BI_CVectorImp<T> provides the base for the sorted vector
                    template BI_SVectorImp<T>. With a sorted vector, you can
                    run through the indices from 0 to the last valid entry,
                    and the objects will emerge in sort order. Here's a
                    simplified extract from vectimp.h:

                     // extract from vectimp.h

                     template <class T> class BI_VectorImp { ... };
                     // direct uncounted, unsorted vector

                     template <class T> class BI_CVectorImp : public
                     BI_VectorImp<T>
                     // direct counted, unsorted vector
                     {
                     public:
                     ...
                       void add( T t );
                     // add at top of array; inc count; resize array if
                     necessary
                       void detach( T t, int del = 0 );
                       void detach( unsigned loc, int del = 0 );
                     // detach given object or object at loc
                     ...
                     };

                     template <class T> class BI_SVectorImp : public
                     BI_CVectorImp<T>
                     // direct counted, sorted vector



                                  - 26 -






                     {
                     public:
                       void add( T t );
                     // add at position that maintains sort
                     };

                     template <class T, class Vect> class
                     BI_InternalIVectorImp :
                     public Vect {...};
                     // interdiate base for BI_IVectorImp: no add

                     template <class T> class BI_IVectorImp :
                     public BI_InternalIVectorImp<T, BI_VectorImp<void *> >
                     {...};
                     // indirect uncounted, unsorted vector: no add

                     template <class T, class Vect> class
                     BI_InternalICVectorImp :
                     public BI_InternalIVectorImp<T, Vect>
                     // intermediate base for BI_ICVector
                     {
                     public:
                       void add( T *t) { Vect::add(t); }
                     ...
                     };

                     template <class T> class BI_ICVectorImp :
                     public BI_InternalICVectorImp<T, BI_CVectorImp<void *>
                     >
                     { ... };
                     // indirect counted vector; can contain any object type

                     template <class T> class BI_ISVectorImp :
                     public BI_InternalICVectorImp<T, BI_SVectorImp<void *>
                     >
                     { ... };
                     // indirect sorted vector


ADT implementation  ========================================================

                    Each ADT is implemented as several templates. For
                    example, the following provides an implementation of a
                    stack of objects of type T using vectors as the FDS:

                     // simplified extract from stacks.h





                                  - 27 -






                     template <class Vect, class T> class
                     BI_StackAsVectorImp
                     {
                     public:
                     ...
                       void push( T t ) { data[current++] = t; }
                     ...

                     protected:
                       Vect data;
                       unsigned current;
                     };

                    The first parameter, class Vect, is either a direct
                    vector or an indirect vector, depending on whether the
                    stack being created is direct or indirect, so Vect will
                    be either BI_VectorImp<T0> or BI_IVectorImp<T0>. The
                    type T represents the type of objects to be stored in
                    the stack. For a direct Vect, T should be the same as
                    T0; for an indirect Vect, T must be of type pointer to
                    T0. A direct stack implemented as a vector looks like
                    this:

                     template <class T> class BI_StackAsVector :
                         public BI_StackAsVectorImp< BI_VectorImp<T>, T >
                     {
                     public:
                         friend class BI_StackAsVectorIterator<T>;
                         ...
                     };

                     template <class T> class BI_StackAsVectorIterator :
                         public BI_VectorIteratorImp<T> {...};

                    That is, a BI_StackAsVector is implemented by using a
                    BI_StackAsVectorImp, whose "implementation" is of type
                    BI_VectorImp<T>, and whose elements are of type T.
                    BI_StackAsVector has its own iterator, derived from
                    underpinning FDS iterator with the contained-object type
                    T as parameter.

                    An indirect stack implemented as a vector looks like
                    this:

                     template <class T> class BI_IStackAsVector :
                         public BI_StackAsVectorImp< BI_IVectorImp<T>, T* >,
                         public virtual TShouldDelete
                     {...};



                                  - 28 -






                    That is, an BI_IStackAsVector is implemented by using a
                    BI_StackAsVectorImp, whose "implementation" is of type
                    BI_IVectorImp<T>, and whose elements are of type pointer
                    to T. The TShouldDelete base provides the ownership
                    control discussed in the Object-based class reference
                    section. TShouldDelete also serves as a second base for
                    the following classes.

Figure 2: TShouldDelete hierarchy

    TShouldDelete*ÄÄÄÄÄÄÂÄÄAssociation*
                        ÃÄÄContainer
                        ÃÄÄBI_IArrayAsVector+
                        ÃÄÄBI_IBagAsVector+
                        ÃÄÄBI_IDequeAsDoubleList+
                        ÃÄÄBI_IDequeAsVector+         *Instance classes
                        ÃÄÄBI_ISArrayAsVector+
                        ÃÄÄBI_ISObjectArray+
                        ÃÄÄBI_IStackAsList+           +Template classes
                        ÀÄÄBI_IStackAsVector+


                    The BI_OStackAsVector and BI_TCStackAsVector versions
                    (stacks of pointers to Objects, emulating the Object
                    container library) now follow easily:

                     class BI_OStackAsVector
                     // non-polymorphic stack with vector of pointers to
                     Objects
                     {
                     public:
                     ...
                       void push( Object *t ) { ostack.push(t); }
                     // ostack is type BI_IStackAsVector<Object>
                     // so we are pushing pointers to Object
                     ...

                     private:
                       BI_IStackAsVector<Object> ostack;
                     };

                     class BI_TCStackAsVector : public Container
                     // polymorphic stack with vector of pointers to
                     Objects
                     // inherits from the Object-based Container class
                     // Provides identical interface and functionality as
                     Object-based Stack // class but underlying data
                     structure is Vector not List



                                  - 29 -






                         {
                     public:
                     ...
                       void push( Object& o ) { stk.push( &o ); }
                     // stk is type BI_OStackAsVector
                     // so we are pushing Objects
                     ...
                     private:
                       BI_OStackAsVector stk;
                     };


                    We end the section with some short examples using the
                    BIDS classes.

            Source   #include <iostream.h>
                     #include <strstream.h>
 Uses the template   #include <arrays.h>
facility to pick a   #include <strng.h>
  specific FDS for
    the array ADT.   int main()
                     {
                        typedef BI_SArrayAsVector<String> lArray;
    In the "sorted      lArray a(2);
   array" FDS, the      for (int i = a.arraySize(); i; i--)
        index of a      {
  particular array         ostrstream os;
element depends on         os << "string " << i << ends;
 its value, not on         a.add( *(new String(os.str())));
the order in which      }
   it was entered.      cout << "array elements;\n";
                        for (i = 0; i < a.arraySize(); ++i)
                        {
   If the ADT used         cout<< a[i] << endl;
  BI_ArrayAsVector      }
     <String>, the      return(0);
    elements would   }
     appear in the
   order they were
      added to the
            array.

            Output   string 1
                     string 2
                     string 3

            Source




                                  - 30 -






Doubly-linked list   #include <iostream.h>
     with indirect   #include <strstream.h>
   storage as FDS.   #include <deques.h>
                     #include <strng.h>

Pointers to String      typedef BI_IDequeAsDoubleList<String> lDeque;
    objects in the
   deque container   int main()
           must be   {
 dereferenced when      lDeque d;
   extracting from      for (int i = 1; i < 5; i++)
        the deque.      {
                           ostrstream os;
                           os << "string " << i << ends;
                           // use alternating left, right insertions
                           if(i&1)
                              d.putLeft(new String(os.str()));
                           else
                              d.putRight(new String(os.str()));
                        }
                        cout << "Deque Contents:" << endl;
                        while (!d.isEmpty())
                        {
                           cout << *d.getLeft() << endl;
                        }
                        return(0);
                     }

            Output   Deque Contents:
                     string 3
                     string 1
                     string 2
                     string 4



===========================================================================
The class library directory
===========================================================================

                    The files in the class library are set up in the
                    following directory structure:









                                  - 31 -






                             ÉÍÍÍÍÍÍÍÍÍÍÍ»
                             º CLASSLIB\ º
                             ÈÍÍÍÍÍÑÍÍÍÍÍ¼
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿
ÉÍÍÍÍÏÍÍÍÍÍ»   ÉÍÍÍÍÏÍÍÍÍ»   ÚÄÄÄÄÄÁÄÄÄÄ¿   ÉÍÍÏÍÍÍ»   ÉÍÍÍÍÏÍÍÍÍÍÍ»
º INCLUDE\ º   º SOURCE\ º   ³   OBJS   ³   º LIB\ º   º EXAMPLES\ º
ÈÍÍÍÍÍÍÍÍÍÍ¼   ÈÍÍÍÍÍÍÍÍÍ¼   ÀÄÄÄÄÄÄÄÄÄÄÙ   ÈÍÍÍÍÍÍ¼   ÈÍÍÍÍÍÍÍÍÍÍÍ¼

                    The CLASSLIB directory is under the TC directory. The
                    contents of the directories in the class library are
                    discussed in more detail in the following sections.


       The INCLUDE  =======================================================
         directory
                    The INCLUDE directory contains the header files
                    necessary to compile a program that uses the class
                    library. You must put this directory on the include
                    search path when you compile your program. Modify
                    Options|Directories|Include Directories if you changed
                    the default setup.

                    For each BIDS ADT (abstract data type), such as Stack,
                    there is a header file called stacks.h. The Object-
                    based class Stack is declared in stack.h. If the
                    identifier TEMPLATES is #defined, either in an .h file
                    or via the command line _D option, then when stack.h is
                    preprocessed, the Object-based declarations for Stack
                    are bypassed and the template versions are included. In
                    particular, if TEMPLATES is #defined, Stack is #defined
                    as BI_TCStackAsList, so any code written for the
                    Object-based Stack will be compiled with the BIDS
                    version.


The OBJS directory  =======================================================

                    Subdirectories of the OBJS directory contain .PRJ file
                    samples.


        The SOURCE  =======================================================
         directory
                    The SOURCE directory contains the source files that
                    implement many of the member functions of the classes
                    in the library. These source files are provided as a
                    guide for implementing new classes.




                                  - 32 -






                    You also need these source files if you want to build a
                    library. There are project files for small and large
                    models, debug and non-debug versions, and template and
                    non-template versions.


------------------  To create a new library using the small memory model,
Creating a library  proceed as follows:
------------------
                    1. Open the CLASSLIBS\OBJS\S (for standard or BIDS) or
                       CLASSLIBS\OBJS\DBS (for debug) directory.

                    2. Create a directory for the new library.

                    3. Copy the project file that's closest to the one you
                       want to create to that directory (use TCLASSS.PRJ to
                       create a standard classlib, TCLASDBS.PRJ to create a
                       debug version, or BIDSS.PRJ to create a templatized
                       version).

                    4. Rename the project file to TCLASSS.PRJ.

                    5. Run TC and select Project|Open TCLASSS.PRJ.

                    6. Set Options|Compiler|Code Generation to the small
                       memory model.

                    7. Select Compile|Build all.

                    8. Copy the resultant .LIB file to the CLASSLIB\LIB
                       directory.

                    For a large memory model, in step 2 copy a xL.PRJ file
                    and in step 3 rename it to TCLASSL.PRJ.

        Important!  When you take a library that you have built and use it
                    in one of the sample projects, you must update the
                    project. See Chapter 7, "Managing multi-file projects"
                    for more information. You must also be sure to compile
                    your project with precisely the same switches and op-
                    tions you used to build the library. If you don't have
                    the same options, you will get warnings from the linker
                    when the executable file is built.








                                  - 33 -






 The LIB directory  =======================================================

                    The LIB directory contains the compiled source modules
                    archived into a library. You must put this directory on
                    the libr